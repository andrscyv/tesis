\chapter{Análisis}

\noindent
Una vez que se ha identificado el problema, se formulará una primera
aproximación a la solución por medio de los requerimientos funcionales que debe
cumplir, así como por las restricciones que debe satisfacer. También se
mostrarán trabajos relacionados.

\newpage

\section{Requerimientos funcionales}

El sistema generará una jugada a partir del estado actual del juego. Es decir,
el programa recibirá como entrada una representación de sus fichas asignadas así
como de las fichas tiradas por los otros participantes y como salida indicará
cual de sus fichas debe jugarse. También será posible elegir distintos niveles
de juego para el programa

\section{Requerimientos no funcionales}

El programa debe generar las jugadas en un tiempo razonable. Debe siempre
terminar la ejecución antes de un lapso predeterminado para poder utilizarse en
un juego de tiempo real contra contrincantes humanos y no debe poseer
información sobre las manos de sus contrincantes ni de su pareja de equipo.

En segundo lugar, el desempeño del programa tiene que ser mejor que la
estrategia más sencilla posible (el jugador greedy): de entre las fichas que se
tiene en la mano, siempre bajar la de mayor puntaje. Una jugada greedy es
sumamente barata de calcular. De no cumplirse con este requisito no tendría
sentido utilizar una estrategia más compleja y costosa en tiempo y recursos
computacionales.

Así, se pone como meta que un equipo de jugadores artificiales debe vencer a un
equipo de jugadores greedy en al menos 70\% de las partidas. Se considera que
este margen es el mínimo para justificar el uso de un algoritmo distinto a la
estrategia greedy.

Por último, debe exponer una API sencilla para ser integrado a distintas
interfaces, tanto aplicaciones web como móviles.

\section{Restricciones}

El software a desarrollar cuenta con distintas restricciones que debe cumplir.
En primer lugar, en cuanto a los recursos para implementar la solución, se
cuenta con un periodo aproximado de 6 meses para completar el desarrollo del
sistema así como de un solo desarrollador (el autor de este trabajo).

En segundo lugar, el sistema debe cumplir con los requerimientos funcionales y
no funcionales dentro de un ambiente de ejecución en la nube con un costo
razonable. Es difícil estimar el costo de los recursos computacionales que
consumirá la solución, pues depende de la cantidad de usuarios del sistema así
como de su comportamiento de uso. No se cuenta con los datos necesarios para
estimar la naturaleza de la carga a la que el sistema debe hacer frente pero se
puede definir unas características mínimas del ambiente de ejecución en el cual
la solución debe correr.

Como un punto de referencia, se ha elegido la instancia más modesta de la
categoría de servidores de cpu compartido de Digital Ocean. Dicho servidor es
una máquina virtual que cuenta con un gigabyte de memoria RAM y un procesador
virtual. Como se describe en la documentación de Digital Ocean, el procesador
virtual es aproximadamente equivalente a un hiperhilo del servidor físico sobre
el que corre. Dependiendo de la carga que experimenten las máquinas virtuales
que corren en el servidor físico, el hiperhilo puede ser compartido con otros
usuarios. En casos en que la máquina virtual tenga una carga alta de trabajo
puede obtener más de un hiperhilo si el servidor físico cuenta con la capacidad
suficiente. El hardware que provee Digital Ocean para el plan básico es una
combinación de procesadores de primera generación (o menos recientes)
\textit{Xeon Scalable} y procesadores \textit{AMD EPYC}

Se considera que un servicio web basado en nuestro sistema, corriendo en el
servidor antes descrito, deberá tener suficiente capacidad para atender las
solicitudes de al menos unos cientos de usuarios al mes. De otra forma, es muy
probable que el costo de la solución sea prohibitivo para su uso.

Por otra parte, debido a que Ubuntu es de licencia libre y que su uso es muy
común en el ecosistema de aplicativos web, se decidió que será la plataforma
principal en la que debe ejecutarse nuestro sistema. Por las mismas razones, se
decidió que el sistema debe estar implementado en el lenguaje \textit{Python 3}.

El uso de bibliotecas de terceros para realizar la implementación puede ser
deseable para ahorrar tiempo de desarrollo. Pero en caso de utilizarse, las
bibliotecas deben satisfacer dos criterios. Primero, deben ser de código
abierto, para que puedan ser modificadas en caso de ser necesario. En segundo
lugar, deben contar con una licencia que permita su uso comercial.

Por último, se destaca que el propósito de este trabajo es obtener un software
apto para su uso en producción y que sea susceptible de modificaciones y mejoras
por distintos desarrolladores, aun cuando esto signifique un rendimiento menor
al que se pueda obtener con técnicas de vanguardia. Así, es deseable utilizar un
algoritmo de ''caja blanca'', buscando que sea más accesible su entendimiento
para las distintas personas encargadas de su mantenimiento y mejora.


\section{Trabajos relacionados}

Uno de los trabajos importante en el ámbito de algoritmos  para juegos de
información imperfecta lo realiza Ginsberg  (2001).  Con esta metodología logra
implementar un jugador de Bridge de nivel experto.

Por otra parte, un jugador artificial en un contexto de incertidumbre puede
estudiarse desde la perspectiva de procesos de decisión de Márkov como en la
disciplina de aprendizaje por refuerzo. En este campo es importante el trabajo
de Mnih et al. (2013) que es uno de los primeros en integrar aprendizaje
profundo a los algoritmos de aprendizaje por refuerzo para la creación de
agentes en el juego de Atari.

Long et al. (2010) realizaron un trabajo en donde , a partir de árboles de juego
sintéticos, definen indicadores estadísticos que les permiten identificar
propiedades importantes de juegos de información imperfecta en los que el método
de \textit{Perfect Information Monte Carlo} (PIMC)  se puede adaptar
exitosamente. Dicho trabajo extiende la línea de investigación sobre las
limitaciones de PIMC en el contexto de información imperfecta que inician Frank
y Basin (1998)

Se recuperó de la web un proyecto de licenciatura sobre un jugador
artificial para dominó (en el texto se le refiere como \textit{Latin-American
dominoes}) desarrollado por Angeris y Li (2016) de la universidad de Stanford.
El proyecto consiste en simulaciones para contrastar distintas algoritmos pero
no tiene la finalidad de ser consumido como una API.

Asimismo, se encontró en Github una implementación del algoritmo \textit{Monte
Carlo Tree Search} (MCTS) en el lenguaje \textit{Python}: mctspy. Entre las
implementaciones de este lenguaje, es la que cuenta con mayor número de
estrellas en Github. También, forma parte de un blog divulgativo sobre MCTS
escrito por el mismo autor que la biblioteca, Kamil Czarnogórski, quien se
identifica por el pseudónimo Int8.

% La siguiente gráfica está hecha a mano porque la que arroja R se pixelea un poco al importarla a LaTeX. Pueden apoyarse en Excel para obtener las coordenadas más rápido

% \begin{figure}[H]
% \begin{center}
% \caption{PIB mundial de los últimos dos milenios}
% \label{PIB_MUN}
% \begin{tikzpicture}
% \begin{axis}[
%     xlabel={Año},
%     ylabel={PIB (billones)},
%     xtick pos=left,
%     ytick pos=left,
%     xtick={500,1000,1500,2000},
%     ytick={0,50,100},
%     scale only axis=true,
%     width=0.6\textwidth,
%     height=0.4\textwidth,
% ]

% \addplot[
%     color=red,
%     ]
%     coordinates {
%     (1,0)(1000,0)(1500,0)(1600,1)(1700,1)(1820,1)(1870,2)(1900,3)(1913,5)(1940,8)(1950,9)(1951,10)(1952,10)(1953,11)(1954,11)(1955,12)(1956,12)(1957,13)(1958,13)(1959,14)(1960,15)(1961,15)(1962,16)(1963,17)(1964,18)(1965,19)(1966,20)(1967,20)(1968,22)(1969,23)(1970,24)(1971,25)(1972,26)(1973,28)(1974,28)(1975,29)(1976,30)(1977,31)(1978,33)(1979,34)(1980,35)(1981,35)(1982,36)(1983,37)(1984,38)(1985,40)(1986,41)(1987,43)(1988,45)(1989,46)(1990,47)(1991,48)(1992,48)(1993,49)(1994,51)(1995,53)(1996,55)(1997,57)(1998,58)(1999,60)(2000,63)(2001,65)(2002,66)(2003,69)(2004,73)(2005,76)(2006,80)(2007,85)(2008,87)(2009,87)(2010,91)(2011,95)(2012,98)(2013,101)(2014,105)(2015,108)
%     };

% \end{axis}
% \end{tikzpicture}

% \imagesource{elaboración propia con datos de Maddison (2010) y el Banco Mundial.}
% \end{center}
% \end{figure}
